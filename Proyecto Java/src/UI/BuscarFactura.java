package UI;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * @author Liu Ching Richard
 */
public class BuscarFactura extends javax.swing.JFrame {

    /**
     * Creates new form BuscarFactura
     */
    public BuscarFactura() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFormattedTextField1 = new javax.swing.JFormattedTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        pantalla = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        volverMenu = new javax.swing.JButton();
        limpiar = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        tipoTransporte = new javax.swing.JComboBox<>();
        jLabel3 = new javax.swing.JLabel();
        fecha = new javax.swing.JFormattedTextField();
        buscar = new javax.swing.JButton();

        jFormattedTextField1.setText("jFormattedTextField1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Liu Ching Richard Proyecto 2");
        setResizable(false);

        pantalla.setColumns(20);
        pantalla.setRows(5);
        jScrollPane1.setViewportView(pantalla);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel1.setText("Buscar Facturas");

        volverMenu.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        volverMenu.setText("Volver al Menú");
        volverMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                volverMenuActionPerformed(evt);
            }
        });

        limpiar.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        limpiar.setText("Limpiar");
        limpiar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                limpiarActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel2.setText("Tipo de Transporte:");

        tipoTransporte.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        tipoTransporte.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Ninguno", "Bicicleta", "Scooter", "Patines" }));

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel3.setText("Fecha (dd/mm/aaaa):");

        fecha.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.DateFormatter(new java.text.SimpleDateFormat("d/M/yyyy"))));
        fecha.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        buscar.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        buscar.setText("Buscar");
        buscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buscarActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(volverMenu)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(limpiar)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(285, 285, 285))
            .addGroup(layout.createSequentialGroup()
                .addGap(57, 57, 57)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(buscar)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 647, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(tipoTransporte, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(fecha, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(66, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(tipoTransporte, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(fecha, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 22, Short.MAX_VALUE)
                .addComponent(buscar)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 430, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(43, 43, 43))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(volverMenu)
                            .addComponent(limpiar))
                        .addContainerGap())))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void volverMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_volverMenuActionPerformed
        // Para que aparezca nuevamente el menu principal
        MenuPrincipal menuPrincipal = new MenuPrincipal();
        menuPrincipal.setVisible(true); // Hace visible el menu principal

        // Cierra la ventana actual
        this.dispose();
    }//GEN-LAST:event_volverMenuActionPerformed

    private void buscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buscarActionPerformed
        // Capturar las entradas
        String seleccionTipoTransporte = tipoTransporte.getSelectedItem().toString();
        String fechaFiltro = fecha.getText();
        
        // Validar el formato de fecha antes de proceder con la busqueda
        if (!fechaFiltro.matches("\\d{1,2}/\\d{1,2}/\\d{4}")) {
            JOptionPane.showMessageDialog(this, "El formato de la fecha debe ser dd/MM/yyyy.", "Error de Formato", JOptionPane.ERROR_MESSAGE);
            return;  // Salir del metodo si el formato de fecha no es valido
        }
        
        ArrayList<String> facturasFiltradas = new ArrayList<>();    // Crea un array con las facturas que se quieren filtrar
        // Limpiar el array
        facturasFiltradas.clear();

        // Leer el archivo Alquiler.txt
        try (BufferedReader br = new BufferedReader(new FileReader("Alquiler.txt"))) {      // Abrir el archivo para lectura
            String linea;
            while ((linea = br.readLine()) != null) {
                // Filtrar segun el tipo de transporte y/o fecha
                String[] datosFactura = linea.split(","); // Los datos estan separados por coma
                if (cumpleFiltroTipoTransporte(datosFactura[3], seleccionTipoTransporte) &&
                    cumpleFiltroFecha(datosFactura[4], fechaFiltro)) {
                    // Formatear la factura y añadirla a la lista de facturas filtradas
                    String facturaFormateada = formatearFactura(datosFactura);
                    facturasFiltradas.add(facturaFormateada);
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Error al leer el archivo.", "Error", JOptionPane.ERROR_MESSAGE);   // Error en caso de no poder leer el archivo
            return;
        }

        // Mostrar las facturas en pantalla
        pantalla.setText("");  // Borra lo que habia en pantalla
        for (String factura : facturasFiltradas) {
            pantalla.append(factura + "\n\n");  // Separar las facturas entre si con espacios
        }
    }//GEN-LAST:event_buscarActionPerformed

    private void limpiarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_limpiarActionPerformed
        // Limpiar el JTextArea
        pantalla.setText("");
        
        // Limpiar los filtros
        fecha.setText("");
        tipoTransporte.setSelectedIndex(0);
        fecha.setValue(null);
    }//GEN-LAST:event_limpiarActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BuscarFactura.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BuscarFactura.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BuscarFactura.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BuscarFactura.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new BuscarFactura().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buscar;
    private javax.swing.JFormattedTextField fecha;
    private javax.swing.JFormattedTextField jFormattedTextField1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton limpiar;
    private javax.swing.JTextArea pantalla;
    private javax.swing.JComboBox<String> tipoTransporte;
    private javax.swing.JButton volverMenu;
    // End of variables declaration//GEN-END:variables

    private boolean cumpleFiltroTipoTransporte(String codigoTransporte, String seleccionTipoTransporte) {
        if (seleccionTipoTransporte.equals("Ninguno")) {
            return true; // Si la seleccion es "Ninguno", no filtramos por tipo de transporte.
        }

        try (BufferedReader br = new BufferedReader(new FileReader("Transporte.txt"))) { // Se lee el archivo Transporte.txt
            String linea;
            while ((linea = br.readLine()) != null) {
                String[] datosTransporte = linea.split(","); // Los datos están separados por coma
                if (datosTransporte[0].equals(codigoTransporte)) { 
                    return datosTransporte[2].equals(seleccionTipoTransporte);  // Compara el valor que esta en la tercera columna de Transporte.txt con la seleccion
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Error al leer el archivo.", "Error", JOptionPane.ERROR_MESSAGE);   // Error en caso de no poder leer el archivo
        }

        return false;
    }

    private boolean cumpleFiltroFecha(String fechaFactura, String fechaFiltro) {
        if (fechaFiltro.isEmpty()) {
            return true; // Si no hay filtro de fecha, no filtramos por fecha.
        }
        
        try {
            // Convertir las fechas a LocalDate para compararlas.
            DateTimeFormatter formatter = new DateTimeFormatterBuilder().appendOptional(DateTimeFormatter.ofPattern("dd/MM/yyyy"))
                .appendOptional(DateTimeFormatter.ofPattern("d/M/yyyy")).toFormatter(); // Para que acepte si no colocan ceros a la izquierda
            LocalDate fechaFacturaDate = LocalDate.parse(fechaFactura, formatter);
            LocalDate fechaFiltroDate = LocalDate.parse(fechaFiltro, formatter);    // Se pasan a Local Date para poder hacer la siguiente comparacion

            // Comprobar si la fecha de la factura es el mismo que se le filtro
             return fechaFacturaDate.isEqual(fechaFiltroDate);
            
        } catch (DateTimeParseException e) {
            // Manejar la excepcion si el formato de la fecha es invalido
            JOptionPane.showMessageDialog(null, "El formato de la fecha debe ser dd/MM/yyyy: ", "Error de Formato", JOptionPane.ERROR_MESSAGE);
        }

        return false;
    }

    private String formatearFactura(String[] datosFactura) {
        // Capturar los datos dentro del archivo Alquiler.txt por columnas
        String nombreCliente = datosFactura[1]; 
        String idCliente = datosFactura[2];
        String tipoTransporte = getTipoTransportePorCodigo(datosFactura[3]); // Implementar esta función
        String codigoTransporte = datosFactura[3];
        String fecha = datosFactura[4];
        String monto = datosFactura[6];
        
        // Formatea la salida como se requiere.
        return String.format("Nombre: %s\nID Cliente: %s\nTipo Transporte: %s\nCódigo Transporte: %s\nFecha: %s\nMonto: %s", // para que salgan los datos como en lista
                nombreCliente, idCliente, tipoTransporte, codigoTransporte, fecha, monto);
    }

    private String getTipoTransportePorCodigo(String codigoTransporte) {
        // Implementar la logica de lectura del archivo Transporte.txt y devolver el tipo de transporte.
        try (BufferedReader br = new BufferedReader(new FileReader("Transporte.txt"))) {  // Leer el archivo
            String linea;
            while ((linea = br.readLine()) != null) {
                String[] datosTransporte = linea.split(","); // Los datos estan separados por coma
                if (datosTransporte[0].equals(codigoTransporte)) {
                    return datosTransporte[2]; // Devuelve el tipo de transporte correspondiente.
                }
            }
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Error al leer el archivo.", "Error", JOptionPane.ERROR_MESSAGE);   // Error en caso de no poder leer el archivo
        }
        return "Desconocido"; // Devuelve un valor por defecto si no se encuentra el codigo.
    }
}
